#!/bin/bash
brew () {
  local pkg=${1}
  local c=''
  if contains "$brews_have" "$pkg" ; then
    if contains "$brews_outdated" "$pkg" ; then
      bake "command brew upgrade $pkg"
    fi
  else
    bake "command brew install $@"
  fi
}
brews_have=$(command brew list)
brews_outdated=$(command brew outdated | awk '{print $1}')
brew_taps=$(command brew tap)

brew_tap () {
  if ! contains "$brew_taps" $1 ; then
    bake "command brew tap $1"
  fi
}

git () {
  git_url=$1
  dir=$2
  if [ -z $dir ]; then
    repo_name=$(basename $1 .git)
    dir="$current_destination/$repo_name"
  fi
  if [ ! -d $dir ]; then
    bake "mkdir -p $dir"
    bake "command git clone $git_url $dir"
  else
    fetch=$(cd $dir
            command git fetch --dry-run)
    if [ -n "$fetch" ]; then
      bake_at $dir
      bake "command git pull"
      bake_at $dir
      bake "command git log HEAD@{1}.."
    fi
  fi
}
github () {
  git "https://github.com/$(echo $1).git" $2
}


nodenv () {
  if ! contains "$(command nodenv versions --bare )" $1; then
    bake "command nodenv install $1"
  fi
}

osx_lookups=$(cat <<EOF
dialogs.expandAll: NSGlobalDomain NSNavPanelExpandedStateForSaveMode -bool true
dialogs.expandAll: NSGlobalDomain PMPrintingExpandedStateForPrint -bool true

ui.fast: NSGlobalDomain NSAutomaticWindowAnimationsEnabled -bool false
ui.fast: NSGlobalDomain NSWindowResizeTime .001

showAllFiles: NSGlobalDomain AppleShowAllExtensions -bool true
finder.disableNetworkDS: com.apple.desktopservices DSDontWriteNetworkStores -bool true

dock.autohide: com.apple.dock autohide -bool true
dock.static: com.apple.dock static-only -bool true

timeMachine.off: com.apple.TimeMachine DoNotOfferNewDisksForBackup -bool true
EOF)

osx () {
  directives=$(echo "$osx_lookups" | grep -e "$1:\s\+")
  echo "$directives" | while read directive; do
    domain=$(get_field "$directive" 2)
    key=$(get_field "$directive" 3)
    val_or_type=$(get_field "$directive" 4)

    if matches "$val_or_type" "^\-"; then
      type=$val_or_type
      val=$(get_field "$directive" 5)
    else
      type='-string'
      val=$val_or_type
    fi

    existing_val=$(defaults read "$domain" "$key")
    existing_type="$(get_field "$(defaults read-type "$domain" "$key")" 3)"

    type_matches=false
    val_matches=false

    if [ "$existing_type" = "-$type" ]; then
      type_matches=true
    elif [[ "$existing_type" = "boolean" ]] && [[ "$type" = "-bool" ]]; then
      type_matches=true
      if [[ $existing_val = 0 ]] && [[ $val = "false" ]]; then
        val_matches=true
      elif [[ $existing_val = 1 ]] && [[ $val = "true" ]]; then
        val_matches=true
      fi
    fi

    if [[ "$val" = "$existing_val" ]]; then
      val_matches=true
    fi

    if [[ $val_matches = false ]] || [[ $type_matches = false ]]; then
      c="defaults write $domain $key $type $val"
      bake "$c"
    fi
  done
}
rbenv () {
  if ! contains "$(command rbenv versions --bare )" $1; then
    bake "command rbenv install $1"
  fi
}


contains () {
  matches "$1" "^$2\$"
}

matches () {
  present=$(echo "$1" | grep -e "$2" > /dev/null)
  return $present
}

replace () {
  echo $(echo "$1" | sed -E 's|'"$2"'|'"$3"'|')
}

substring () {
  echo $(expr "$1" : $2)
}

get_field () {
  echo $(echo "$1" | awk '{print $'"$2"'}')
}

current_destination=$PWD
set_dir () {
  current_destination=$1
}
unset_dir () {
  current_destination=$PWD
}

include () {
  if [ -e "$scriptDir/$1" ]; then
    # if [ $operation = 'build' ]; then
    #   echo "$scriptDir/$1"
    # else
      . "$scriptDir/$1"
    # fi
  else
    echo "include: $scriptDir/$1: No such file or directory"
    exit 1
  fi
}

baking_dir=$PWD
bake_at () {
  baking_dir=$1
}
bake () {
  if [ $operation = 'install' ]; then
    echo "$1"
    (
      cd $baking_dir
      $1
    )
    status="$(echo $?)"
    baking_dir=$PWD
    if [ "$status" -gt "0" ]; then
      exit $status
    fi
  elif [ $operation = 'print' ]; then
    echo "$1"
  fi
}
script=$1
scriptName=$(basename $script)
scriptDir=$(dirname $script)

operation='install'

include $scriptName
